---
name: build-u3s
on:
  workflow_call:
    inputs:
      ucore_version:
        description: 'The uCore stream: stable, stable-zfs, stable-nvidia etc'
        required: true
        type: string

env:
  IMAGE_DESC: "k3s running on a uCore-based (CoreOS) system"
  IMAGE_REGISTRY: "ghcr.io/${{ github.repository_owner }}"
  IMAGE_LOGO_URL: "https://avatars.githubusercontent.com/u/120078124?s=200&v=4"
  IMAGE_KEYWORDS: "bootc,ublue,universal-blue,ucore,k3s,crio"

concurrency:
  group: ${{ github.workflow }}-${{ github.ref || github.run_id }}-${{ inputs.brand_name}}-${{ inputs.stream_name }}
  cancel-in-progress: true

jobs:
  workflow_info:
    name: Get Workflow Info
    runs-on: ubuntu-24.04
    outputs:
      pr_prefix: ${{ steps.pr_prefix.outputs.pre_prefix }}
    steps:
      - name: Set PR Prefix
        id: pr_prefix
        shell: bash
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
              PR_PREFIX="pr-${{ github.event.number }}-"
          else
              PR_PREFIX=""
          fi
          echo "pr_prefix=${PR_PREFIX}" >> $GITHUB_OUTPUT
      - name: Echo outputs
        run: |
          echo "${{ toJSON(steps.pr_prefix.outputs) }}"
  stream_info:
    name: Get Stream Info
    runs-on: ubuntu-24.04
    outputs:
      fedora: ${{ fromJSON(steps.fetch_ucore.outputs.outputs).fedora}}
      image: ${{ fromJSON(steps.fetch_ucore.outputs.outputs).image}}
      kernel: ${{ fromJSON(steps.fetch_ucore.outputs.outputs).kernel}}
    steps:
      - name: Fetch uCore stream versions
        id: fetch_ucore
        uses: Wandalen/wretry.action@e68c23e6309f2871ca8ae4763e7629b9c258e1ea # v3.8.0
        with:
          attempt_limit: 3
          attempt_delay: 15000
          command: |
            set -eo pipefail

            skopeo inspect docker://ghcr.io/ublue-os/ucore-minimal:${{ inputs.ucore_version }} > inspect.json

            image=$(jq -r '.["Labels"]["org.opencontainers.image.version"]' inspect.json)

            fedora=$(echo "$image" | cut -f1 -d.)
            if [ -z "$fedora" ] || [ "null" = "$fedora" ]; then
                echo "fedora version must not be empty or null"
                exit 1
            fi

            kernel=$(skopeo inspect docker://ghcr.io/ublue-os/ucore-minimal:${{ inputs.ucore_version }} | jq -r '.["Labels"]["ostree.linux"]')
            if [ -z "$kernel" ] || [ "null" = "$kernel" ]; then
                echo "inspected linux (kernel) version must not be empty or null"
                exit 1
            fi

            echo "kernel=$kernel" >> $GITHUB_OUTPUT
            echo "image=$image" >> $GITHUB_OUTPUT
            echo "fedora=$fedora" >> $GITHUB_OUTPUT
      - name: Echo outputs
        run: |
          echo "${{ steps.fetch_ucore.outputs.outputs }}"
  kubernetes_info:
    name: Get Kubernetes Info
    runs-on: ubuntu-24.04
    outputs:
      k3s_version: ${{ fromJSON(steps.fetch_k8s.outputs.outputs).k3s_version}}
      k3s_binary_url: ${{ fromJSON(steps.fetch_k8s.outputs.outputs).k3s_binary_url}}
      k3s_binary_digest: ${{ fromJSON(steps.fetch_k8s.outputs.outputs).k3s_binary_digest}}
      k8s_version: ${{ fromJSON(steps.fetch_k8s.outputs.outputs).k8s_version}}
      crio_version: ${{ fromJSON(steps.fetch_k8s.outputs.outputs).crio_version}}
      calico_version: ${{ fromJSON(steps.fetch_k8s.outputs.outputs).calico_version}}
      calico_binary_url: ${{ fromJSON(steps.fetch_k8s.outputs.outputs).calico_binary_url}}
      calico_binary_digest: ${{ fromJSON(steps.fetch_k8s.outputs.outputs).calico_binary_digest}}
    steps:
      - name: Fetch details of k3s, k8s and crio
        id: fetch_k8s
        uses: Wandalen/wretry.action@e68c23e6309f2871ca8ae4763e7629b9c258e1ea # v3.8.0
        with:
          attempt_limit: 3
          attempt_delay: 15000
          command: |
            set -eo pipefail

            CRIO_REPO="cri-o/cri-o"
            K3S_REPO="k3s-io/k3s"
            CALICO_REPO="projectcalico/calico"

            CRIO_RELEASES_FILE="cri-o_releases.json"
            K3S_RELEASES_FILE="k3s_releases.json"
            CALICO_RELEASES_FILE="calico_releases.json"

            ## Function to fetch and save releases from GitHub API
            fetch_releases() {
                local repo=$1
                local filename=$2
                echo "Fetching releases for ${repo}..."
                curl -sSL -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" "https://api.github.com/repos/${repo}/releases" -o "$filename"
                if [ ! -s "$filename" ]; then
                    echo "Error: Failed to fetch releases for ${repo} or file is empty."
                    exit 1
                fi
              }

            ## Fetch all required release data
            fetch_releases "$CRIO_REPO" "$CRIO_RELEASES_FILE"
            fetch_releases "$K3S_REPO" "$K3S_RELEASES_FILE"
            fetch_releases "$CALICO_REPO" "$CALICO_RELEASES_FILE"

            ## Find common major.minor versions between K3s and CRI-O
            echo "Finding compatible major.minor versions..."
            crio_versions=($(jq -r '[.[] | select(.prerelease|not)] | .[].tag_name | cut -f1,2 -d.' "$CRIO_RELEASES_FILE" | sort -u))
            k3s_versions=($(jq -r '[.[] | select(.prerelease|not)] | .[].tag_name | cut -f1,2 -d.' "$K3S_RELEASES_FILE" | sort -u))

            valid_versions=($(comm -12 <(printf "%s\n" "${k3s_versions[@]}") <(printf "%s\n" "${crio_versions[@]}")))

            if [ ${#valid_versions[@]} -eq 0 ]; then
              echo "Error: No common major.minor versions found between CRI-O and K3s. Exiting."
              exit 1
            fi

            echo "Found compatible major.minor versions: ${valid_versions[*]}"

            ## Use a single jq call to find the latest compatible release and extract details
            valid_re=$(IFS="|"; echo "${valid_versions[*]}")
            k3s_latest_compatible=$(jq -r --arg valid_re "$valid_re" '[.[] | select(.tag_name|test($valid_re))] | [.[] | select(.prerelease|not)] | .[0]' "$K3S_RELEASES_FILE")
            crio_latest_compatible=$(jq -r --arg valid_re "$valid_re" '[.[] | select(.tag_name|test($valid_re))] | [.[] | select(.prerelease|not)] | .[0]' "$CRIO_RELEASES_FILE")

            ## Extract variables from the JSON objects
            crio_version=$(echo "$crio_latest_compatible" | jq -r '.tag_name')
            k3s_version=$(echo "$k3s_latest_compatible" | jq -r '.tag_name')
            k8s_version=$crio_version
            k3s_binary_url=$(echo "$k3s_latest_compatible" | jq -r '.assets[] | select(.name == "k3s") | .browser_download_url')
            k3s_binary_digest=$(echo "$k3s_latest_compatible" | jq -r '.assets[] | select(.name == "k3s") | .digest')

            ## Extract latest non-prerelease Calico version and binary info
            calico_latest=$(jq -r '[.[] | select(.prerelease|not)][0]' "$CALICO_RELEASES_FILE")
            calico_version=$(echo "$calico_latest" | jq -r '.tag_name')
            calico_binary_url=$(echo "$calico_latest" | jq -r '.assets[] | select(.name == "calicoctl-linux-amd64") | .browser_download_url')
            calico_binary_digest=$(echo "$calico_latest" | jq -r '.assets[] | select(.name == "calicoctl-linux-amd64") | .digest')

            ## Write to GitHub Actions output
            echo "k3s_version=$k3s_version" >> $GITHUB_OUTPUT
            echo "k3s_binary_url=$k3s_binary_url" >> $GITHUB_OUTPUT
            echo "k3s_binary_digest=$k3s_binary_digest" >> $GITHUB_OUTPUT
            echo "k8s_version=$k8s_version" >> $GITHUB_OUTPUT
            echo "crio_version=$crio_version" >> $GITHUB_OUTPUT
            echo "calico_version=$calico_version" >> $GITHUB_OUTPUT
            echo "calico_binary_url=$calico_binary_url" >> $GITHUB_OUTPUT
            echo "calico_binary_digest=$calico_binary_digest" >> $GITHUB_OUTPUT

            ## Clean up temporary files
            rm "$CRIO_RELEASES_FILE" "$K3S_RELEASES_FILE" "$CALICO_RELEASES_FILE"

      - name: Echo outputs
        run: |
          echo "${{ steps.fetch_k8s.outputs.outputs }}"

  build_u3s:
    name: u3s
    runs-on: ubuntu-24.04
    if: always() && !cancelled()
    needs: [workflow_info, stream_info, kubernetes_info]
    permissions:
      contents: read
      packages: write
    env:
      FEDORA_VERSION: ${{ needs.stream_info.outputs.fedora}}
      IMAGE_VERSION: ${{ needs.stream_info.outputs.image}}
      IMAGE_NAME: ${{ github.event.repository.name }}
      UCORE_VERSION: ${{ inputs.ucore_version }}
      KERNEL_VERSION: ${{ needs.stream_info.outputs.kernel}}
      PR_PREFIX: ${{ needs.workflow_info.outputs.pr_prefix }}
      K3S_VERSION: ${{ needs.kubernetes_info.outputs.k3s_version }}
      K3S_BINARY_URL: ${{ needs.kubernetes_info.outputs.k3s_binary_url }}
      K3S_BINARY_DIGEST: ${{ needs.kubernetes_info.outputs.k3s_binary_digest }}
      K8S_VERSION: ${{ needs.kubernetes_info.outputs.k8s_version }}
      CRIO_VERSION: ${{ needs.kubernetes_info.outputs.crio_version }}
      CALICO_VERSION: ${{ needs.kubernetes_info.outputs.calico_version }}
      CALICO_BINARY_URL: ${{ needs.kubernetes_info.outputs.calico_binary_url }}
      CALICO_BINARY_DIGEST: ${{ needs.kubernetes_info.outputs.calico_binary_digest }}

    steps:
      # Checkout push-to-registry action GitHub repository
      - name: Checkout Push to Registry action
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5

      - name: Verify versions (image, kernel, ucore, k3s, k8, crio)
        shell: bash
        run: |
          set -x
          if [ -z "${{ env.FEDORA_VERSION }}" ] || [ "null" = "${{ env.FEDORA_VERSION }}" ]; then
              echo "env.FEDORA_VERSION must not be empty or null"
              exit 1
          fi
          if [ -z "${{ env.IMAGE_VERSION }}" ] || [ "null" = "${{ env.IMAGE_VERSION }}" ]; then
              echo "env.IMAGE_VERSION must not be empty or null"
              exit 1
          fi
          if [ -z "${{ env.UCORE_VERSION }}" ] || [ "null" = "${{ env.UCORE_VERSION }}" ]; then
              echo "env.UCORE_VERSION must not be empty or null"
              exit 1
          fi
          if [ -z "${{ env.KERNEL_VERSION }}" ] || [ "null" = "${{ env.KERNEL_VERSION }}" ]; then
              echo "env.KERNEL_VERSION must not be empty or null"
              exit 1
          fi
          if [ -z "${{ env.K3S_VERSION }}" ] || [ "null" = "${{ env.K3S_VERSION }}" ]; then
              echo "env.K3S_VERSION must not be empty or null"
              exit 1
          fi
          if [ -z "${{ env.K3S_BINARY_URL }}" ] || [ "null" = "${{ env.K3S_BINARY_URL }}" ]; then
              echo "env.K3S_BINARY_URL must not be empty or null"
              exit 1
          fi
          if [ -z "${{ env.K3S_BINARY_DIGEST }}" ] || [ "null" = "${{ env.K3S_BINARY_URL }}" ]; then
              echo "env.K3S_BINARY_DIGEST must not be empty or null"
              exit 1
          fi
          if [ -z "${{ env.K8S_VERSION }}" ] || [ "null" = "${{ env.K8S_VERSION }}" ]; then
              echo "env.K8S_VERSION must not be empty or null"
              exit 1
          fi
          if [ -z "${{ env.CRIO_VERSION }}" ] || [ "null" = "${{ env.CRIO_VERSION }}" ]; then
              echo "env.CRIO_VERSION must not be empty or null"
              exit 1
          fi
          if [ -z "${{ env.CALICO_VERSION }}" ] || [ "null" = "${{ env.CALICO_VERSION }}" ]; then
              echo "env.CALICO_VERSION must not be empty or null"
              exit 1
          fi
          if [ -z "${{ env.CALICO_BINARY_URL }}" ] || [ "null" = "${{ env.CALICO_BINARY_URL }}" ]; then
              echo "env.CALICO_BINARY_URL must not be empty or null"
              exit 1
          fi
          if [ -z "${{ env.CALICO_BINARY_DIGEST }}" ] || [ "null" = "${{ env.CALICO_BINARY_DIGEST }}" ]; then
              echo "env.CALICO_BINARY_DIGEST must not be empty or null"
              exit 1
          fi

      - name: Get current date
        id: date
        run: |
          # This generates a timestamp like what is defined on the ArtifactHub documentation
          # E.G: 2022-02-08T15:38:15Z'
          # https://artifacthub.io/docs/topics/repositories/container-images/
          # https://linux.die.net/man/1/date
          echo "date=$(date -u +%Y\-%m\-%d\T%H\:%M\:%S\Z)" >> $GITHUB_OUTPUT

      - name: Generate tags
        id: generate-tags
        shell: bash
        run: |
          # Generate a timestamp for creating an image version history
          TIMESTAMP="$(date +%Y%m%d)"
          UCORE_VERSION="${{ inputs.ucore_version }}"

          COMMIT_TAGS=()
          BUILD_TAGS=()

          # Have tags for tracking builds during pull request
          SHA_SHORT="${GITHUB_SHA::7}"
          COMMIT_TAGS+=("pr-${{ github.event.number }}-${UCORE_VERSION}")
          COMMIT_TAGS+=("${SHA_SHORT}-${UCORE_VERSION}")

          BUILD_TAGS=("${UCORE_VERSION}" "${UCORE_VERSION}-${TIMESTAMP}")
          # always add the '-k3s' tag to each image since we include ZFS with them all
          # and we want users of the existing '-k3s' images to still get updates
          BUILD_TAGS+=("${UCORE_VERSION}-k3s")
          BUILD_TAGS+=("${UCORE_VERSION}-k3s-${TIMESTAMP}")

          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
              echo "Generated the following commit tags: "
              for TAG in "${COMMIT_TAGS[@]}"; do
                  echo "${TAG}"
              done

              alias_tags=("${COMMIT_TAGS[@]}")
          else
              if [[ "${UCORE_VERSION}" == "stable" ]]; then
                  BUILD_TAGS+=("latest")
              fi

              alias_tags=("${BUILD_TAGS[@]}")
          fi

          echo "Generated the following build tags: "
          for TAG in "${BUILD_TAGS[@]}"; do
              echo "${TAG}"
          done

          echo "alias_tags=${alias_tags[*]}" >> $GITHUB_OUTPUT

      # Image metadata for https://artifacthub.io/ - This is optional but is highly recommended so we all can get a index of all the custom images
      # The metadata by itself is not going to do anything, you choose if you want your image to be on ArtifactHub or not.
      - name: Image Metadata
        uses: docker/metadata-action@c1e51972afc2121e065aed6d45c65596fe445f3f # v5
        id: metadata
        with:
          images: |
            ${{ env.IMAGE_NAME }}
          labels: |
            io.artifacthub.package.readme-url=https://raw.githubusercontent.com/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}/refs/heads/main/README.md
            org.opencontainers.image.created=${{ steps.date.outputs.date }}
            org.opencontainers.image.description=${{ env.IMAGE_DESC }}
            org.opencontainers.image.documentation=https://raw.githubusercontent.com/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}/refs/heads/main/README.md
            org.opencontainers.image.source=https://github.com/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}/blob/main/Containerfile
            org.opencontainers.image.title=${{ env.IMAGE_NAME }}
            org.opencontainers.image.url=https://github.com/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}
            org.opencontainers.image.vendor=${{ github.repository_owner }}
            org.opencontainers.image.version=${{ env.IMAGE_VERSION}}-${{ env.K3S_VERSION }}
            io.artifacthub.package.deprecated=false
            io.artifacthub.package.keywords=${{ env.IMAGE_KEYWORDS }}
            io.artifacthub.package.license=Apache-2.0
            io.artifacthub.package.logo-url=${{ env.IMAGE_LOGO_URL }}
            io.artifacthub.package.prerelease=false
            containers.bootc=1

      - name: Build Image
        id: build_image
        uses: redhat-actions/buildah-build@7a95fa7ee0f02d552a32753e7414641a04307056 # v2
        with:
          containerfiles: |
            ./u3s/Containerfile
          context: ./u3s
          image: ${{ env.IMAGE_NAME }}
          tags: |
            ${{ steps.generate-tags.outputs.alias_tags }}
          build-args: |
            FEDORA_VERSION=${{ env.FEDORA_VERSION }}
            IMAGE_VERSION=${{ env.IMAGE_VERSION }}
            UCORE_VERSION=${{ inputs.ucore_version }}
            K3S_VERSION=${{ env.K3S_VERSION }}
            K3S_BINARY_URL=${{ env.K3S_BINARY_URL }}
            K3S_BINARY_DIGEST=${{ env.K3S_BINARY_DIGEST }}
            K8S_VERSION=${{ env.K8S_VERSION }}
            CRIO_VERSION=${{ env.CRIO_VERSION }}
            CALICO_VERSION=${{ env.CALICO_VERSION }}
            CALICO_BINARY_URL=${{ env.CALICO_BINARY_URL }}
            CALICO_BINARY_DIGEST=${{ env.CALICO_BINARY_DIGEST }}
          labels: ${{ steps.metadata.outputs.labels }}
          oci: false
          extra-args: |
            --target=${{ env.IMAGE_NAME }}

      # Workaround bug where capital letters in your GitHub username make it impossible to push to GHCR.
      # https://github.com/macbre/push-to-ghcr/issues/12
      - name: Lowercase Registry
        id: registry_case
        uses: ASzc/change-string-case-action@d0603cd0a7dd490be678164909f65c7737470a7f # v6
        with:
          string: ${{ env.IMAGE_REGISTRY }}


      # Push the image to GHCR (Image Registry)
      - name: Push To GHCR
        uses: Wandalen/wretry.action@e68c23e6309f2871ca8ae4763e7629b9c258e1ea # v3.8.0
        id: push
        if: github.event_name != 'pull_request'
        env:
          REGISTRY_USER: ${{ github.actor }}
          REGISTRY_PASSWORD: ${{ github.token }}
        with:
          action: redhat-actions/push-to-registry@v2
          attempt_limit: 3
          attempt_delay: 15000
          with: |
            image: ${{ steps.build_image.outputs.image }}
            tags: ${{ steps.build_image.outputs.tags }}
            registry: ${{ steps.registry_case.outputs.lowercase }}
            username: ${{ env.REGISTRY_USER }}
            password: ${{ env.REGISTRY_PASSWORD }}
            extra-args: |
              --disable-content-trust

      - name: Login to GitHub Container Registry
        uses: docker/login-action@184bdaa0721073962dff0199f1fb9940f07167d1 # v3
        if: github.event_name != 'pull_request'
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Sign container
      - uses: sigstore/cosign-installer@d58896d6a1865668819e1d91763c7751a165e159 # v3.9.2
        if: github.event_name != 'pull_request'

      - name: Sign container image
        if: github.event_name != 'pull_request'
        run: |
          cosign sign -y --key env://COSIGN_PRIVATE_KEY ${{ steps.registry_case.outputs.lowercase }}/${{ steps.build_image.outputs.image }}@${TAGS}
        env:
          TAGS: ${{ steps.push.outputs.outputs && fromJSON(steps.push.outputs.outputs).digest }}
          COSIGN_EXPERIMENTAL: false
          COSIGN_PRIVATE_KEY: ${{ secrets.SIGNING_SECRET }}

      - name: Echo outputs
        if: github.event_name != 'pull_request'
        run: |
          echo "${{ toJSON(steps.push.outputs) }}"
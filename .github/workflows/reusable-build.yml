---
name: build-u3s
on:
  workflow_call:
    inputs:
      coreos_version:
        description: "The CoreOS stream: stable or testing"
        required: true
        type: string
      arch:
        description: "JSON string of architectures to build, '[aarch64, x86_64]'"
        default: "['x86_64']"
        required: false
        type: string

env:
  IMAGE_DESC: "k3s running on a uCore-based (CoreOS) system"
  IMAGE_REGISTRY: "ghcr.io/${{ github.repository_owner }}"
  IMAGE_LOGO_URL: "https://avatars.githubusercontent.com/u/120078124?s=200&v=4"
  IMAGE_KEYWORDS: "bootc,ublue,universal-blue,ucore,k3s,crio"
  KERNEL_FLAVOR: ${{ inputs.coreos_version == 'stable' && 'longterm-6.12' || format('coreos-{0}', inputs.coreos_version) }}
  COREOS_VERSION: ${{ inputs.coreos_version }}

concurrency:
  group: ${{ github.workflow }}-${{ github.ref || github.run_id }}-${{ inputs.coreos_version }}-${{ inputs.k3s_version }}
  cancel-in-progress: true

jobs:
  workflow_info:
    name: Get Workflow Info
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      date: ${{ steps.date.outputs.date }}
      pr_prefix: ${{ steps.pr_prefix.outputs.pre_prefix }}
    steps:
      - name: Get current date
        id: date
        run: echo "date=$(date +'%Y%m%d')" >> $GITHUB_OUTPUT
      - name: Set PR Prefix
        id: pr_prefix
        shell: bash
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
              PR_PREFIX="pr-${{ github.event.number }}-"
          else
              PR_PREFIX=""
          fi
          echo "pr_prefix=${PR_PREFIX}" >> $GITHUB_OUTPUT
      - name: Echo outputs
        run: |
          echo "${{ toJSON(steps.date.outputs) }}"
          echo "${{ toJSON(steps.pr_prefix.outputs) }}"
  stream_info:
    name: "Get Stream Info: ${{ matrix.arch }}"
    runs-on: ${{ matrix.arch == 'x86_64' && 'ubuntu-24.04' || matrix.arch == 'aarch64' && 'ubuntu-24.04-arm' }}
    permissions:
      actions: write
    strategy:
      fail-fast: false
      matrix:
        arch: ${{ fromJSON(inputs.arch) }}
    steps:
      - name: Fetch CoreOS stream versions
        id: fetch
        uses: Wandalen/wretry.action@e68c23e6309f2871ca8ae4763e7629b9c258e1ea # v3.8.0
        with:
          attempt_limit: 3
          attempt_delay: 15000
          command: |
            set -eo pipefail

            skopeo inspect docker://quay.io/fedora/fedora-coreos:${{ inputs.coreos_version }} > inspect.json

            image=$(jq -r '.["Labels"]["org.opencontainers.image.version"]' inspect.json)
            if [ -z "$image" ] || [ "null" = "$image" ]; then
              echo "inspected image version must not be empty or null" >&2
              exit 1
            fi

            if [[ "${image}" =~ "42.20250410.3" ]]; then
              echo "WARNING: Overriding known problematic release. Downgrading from 42.20250410.3.* to 41.20250331.3.0" >&2
              image="41.20250331.3.0"
            fi

            fedora=$(echo "$image" | cut -f1 -d.)
            if [ -z "$fedora" ] || [ "null" = "$fedora" ]; then
              echo "fedora version must not be empty or null" >&2
              exit 1
            fi

            kernel=$(skopeo inspect docker://ghcr.io/ublue-os/akmods-zfs:${{ env.KERNEL_FLAVOR }}-${fedora} | jq -r '.["Labels"]["ostree.linux"]')
            if [ -z "$kernel" ] || [ "null" = "$kernel" ]; then
              echo "inspected linux (kernel) version must not be empty or null" >&2
              exit 1
            fi

            echo "FEDORA_VERSION=${fedora}" > stream-info.env
            echo "IMAGE_VERSION=${image}" >> stream-info.env
            echo "KERNEL_VERSION=${kernel}" >> stream-info.env

            cat stream-info.env
      - name: Upload stream info as artifact
        uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4 # v5.0.0
        with:
          name: stream-info-${{ matrix.arch }}
          path: |
            stream-info.env
          retention-days: 7
  kubernetes_info:
    name: Get Kubernetes Info
    runs-on: ubuntu-latest
    permissions:
      actions: write
    steps:
      - name: Fetch details of k3s, k8s and crio
        id: fetch_k8s
        uses: Wandalen/wretry.action@e68c23e6309f2871ca8ae4763e7629b9c258e1ea # v3.8.0
        with:
          attempt_limit: 3
          attempt_delay: 15000
          command: |
            set -eo pipefail

            CRIO_REPO="cri-o/cri-o"
            K3S_REPO="k3s-io/k3s"
            CALICO_REPO="projectcalico/calico"

            CRIO_RELEASES_FILE="cri-o_releases.json"
            K3S_RELEASES_FILE="k3s_releases.json"
            CALICO_RELEASES_FILE="calico_releases.json"

            ## Function to fetch and save releases from GitHub API
            fetch_releases() {
                local repo=$1
                local filename=$2
                echo "Fetching releases for ${repo}..."
                curl -sSL -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" "https://api.github.com/repos/${repo}/releases" -o "$filename"
                if [ ! -s "$filename" ]; then
                    echo "Error: Failed to fetch releases for ${repo} or file is empty."
                    exit 1
                fi
              }

            ## Fetch all required release data
            fetch_releases "$CRIO_REPO" "$CRIO_RELEASES_FILE"
            fetch_releases "$K3S_REPO" "$K3S_RELEASES_FILE"
            fetch_releases "$CALICO_REPO" "$CALICO_RELEASES_FILE"

            ## Find newest common x.y versions between K3s and CRI-O
            crio_versions=($(jq -r '[.[] | select(.prerelease|not)] | .[].tag_name' "$CRIO_RELEASES_FILE" | cut -f1,2 -d. | sort -u))
            k3s_versions=($(jq -r '[.[] | select(.prerelease|not)] | .[].tag_name' "$K3S_RELEASES_FILE" | cut -f1,2 -d. | sort -u))
            valid_versions=($(comm -12 <(printf "%s\n" "${k3s_versions[@]}") <(printf "%s\n" "${crio_versions[@]}")))

            if [ ${#valid_versions[@]} -eq 0 ]; then
              echo "Error: No common major.minor versions found between CRI-O and K3s. Exiting."
              exit 1
            fi

            echo "Found compatible major.minor versions: ${valid_versions[@]}"

            crio_version=$(jq -r --arg valid_re "$(IFS="|"; echo "${valid_versions[*]}")" '[.[] | select(.tag_name|test($valid_re))] | [.[] | select(.prerelease|not)] | .[0].tag_name' "$CRIO_RELEASES_FILE" | cut -f1,2 -d.)
            k3s_version=$(jq -r --arg valid_re "$(IFS="|"; echo "${valid_versions[*]}")" '[.[] | select(.tag_name|test($valid_re))] | [.[] | select(.prerelease|not)] | .[0].tag_name' "$K3S_RELEASES_FILE")
            k8s_version=${crio_version}

            k3s_binary_url=$(jq -r --arg valid_re "$(IFS="|"; echo "${valid_versions[*]}")" '[.[] | select(.tag_name|test($valid_re))] | [.[] | select(.prerelease|not)] | .[0].assets[] | select(.name == "k3s") | .browser_download_url' "$K3S_RELEASES_FILE")
            k3s_binary_digest=$(jq -r --arg valid_re "$(IFS="|"; echo "${valid_versions[*]}")" '[.[] | select(.tag_name|test($valid_re))] | [.[] | select(.prerelease|not)] | .[0].assets[] | select(.name == "k3s") | .digest' "$K3S_RELEASES_FILE")

            echo "K3S_VERSION=$k3s_version" > kubernetes-info.env
            echo "K3S_BINARY_URL=$k3s_binary_url" >> kubernetes-info.env
            echo "K3S_BINARY_DIGEST=$k3s_binary_digest" >> kubernetes-info.env
            echo "K8S_VERSION=$k8s_version" >> kubernetes-info.env
            echo "CRIO_VERSION=$crio_version" >> kubernetes-info.env
      - name: Upload kubernetes info as artifact
        uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4 # v5.0.0
        with:
          name: kubernetes-info
          path: |
            kubernetes-info.env
          retention-days: 7
  binary_info:
    name: Get Binary Info
    runs-on: ubuntu-latest
    permissions:
      actions: write
    steps:
      - name: Fetch details for various binaries
        id: fetch_bins
        uses: Wandalen/wretry.action@e68c23e6309f2871ca8ae4763e7629b9c258e1ea # v3.8.0
        with:
          attempt_limit: 3
          attempt_delay: 15000
          command: |
            set -eo pipefail

            CALICO_REPO="projectcalico/calico"
            HELM_REPO="helm/helm"

            CALICO_RELEASES_FILE="calico_releases.json"
            HELM_RELEASES_FILE="helm_releases.json"

            ## Function to fetch and save releases from GitHub API
            fetch_releases() {
                local repo=$1
                local filename=$2
                echo "Fetching releases for ${repo}..."
                curl -sSL -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" "https://api.github.com/repos/${repo}/releases" -o "$filename"
                if [ ! -s "$filename" ]; then
                    echo "Error: Failed to fetch releases for ${repo} or file is empty."
                    exit 1
                fi
              }

            ## Fetch all required release data
            fetch_releases "$CALICO_REPO" "$CALICO_RELEASES_FILE"
            fetch_releases "$HELM_REPO" "$HELM_RELEASES_FILE"

            calico_version=$(jq -r '[.[] | select(.prerelease|not)][0] | .tag_name' "$CALICO_RELEASES_FILE")
            calico_binary_url=$(jq -r '[.[] | select(.prerelease|not)][0] | .assets[] | select(.name == "calicoctl-linux-amd64") | .browser_download_url' "$CALICO_RELEASES_FILE")
            calico_binary_digest=$(jq -r '[.[] | select(.prerelease|not)][0] | .assets[] | select(.name == "calicoctl-linux-amd64") | .digest' "$CALICO_RELEASES_FILE")

            helm_version=$(jq -r '[.[] | select(.prerelease|not)][0] | .tag_name' "$HELM_RELEASES_FILE")
            helm_binary_tarball=$(jq -r --arg helm_arch_ver "linux-amd64" '[.[] | select(.prerelease|not)][0] | .assets[] | select(.name|test($helm_arch_ver)) | .name' "$HELM_RELEASES_FILE" | cut -f1,2,3,4,5 -d. | uniq)
            helm_binary_url="https://get.helm.sh/${helm_binary_tarball}"

            echo "CALICO_VERSION=$calico_version" > binary-info.env
            echo "CALICO_BINARY_URL=$calico_binary_url" >> binary-info.env
            echo "CALICO_BINARY_DIGEST=$calico_binary_digest" >> binary-info.env
            echo "HELM_VERSION=$helm_version" >> binary-info.env
            echo "HELM_BINARY_URL=$helm_binary_url" >> binary-info.env
            echo "HELM_BINARY_TARBALL=$helm_binary_tarball" >> binary-info.env
      - name: Upload kubernetes info as artifact
        uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4 # v5.0.0
        with:
          name: binary-info
          path: |
            binary-info.env
          retention-days: 7

  build_image:
    name: "Build: u3s${{ matrix.image_suffix }}${{ matrix.nvidia_tag }}: ${{ matrix.arch }}"
    if: needs.workflow_info.result == 'success' && needs.stream_info.result == 'success'  && needs.kubernetes_info.result == 'success' && needs.binary_info.result == 'success' && !cancelled()
    needs: [workflow_info, stream_info, kubernetes_info, binary_info]
    runs-on: ${{ matrix.arch == 'x86_64' && 'ubuntu-24.04' || matrix.arch == 'aarch64' && 'ubuntu-24.04-arm' }}
    permissions:
      actions: write
      contents: read
      packages: write
    env:
      PR_PREFIX: ${{ needs.workflow_info.outputs.pr_prefix }}
    strategy:
      fail-fast: false
      matrix:
        arch: ${{ fromJson(inputs.arch) }}
        image_suffix:
          - ""
        nvidia_tag:
          - "-nvidia"
          - ""
        include:
          - image_suffix: ""
            description: An OCI image of Fedora CoreOS with k3s

    steps:
      # Checkout push-to-registry action GitHub repository
      - name: Checkout Push to Registry action
        uses: actions/checkout@1af3b93b6815bc44a9784bd300feb67ff0d1eeb3 # v6

      - name: Download stream info artifact
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v6
        with:
          name: stream-info-${{ matrix.arch }}
          path: .
      - name: Download kubernetes info artifact
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v6
        with:
          name: kubernetes-info
          path: .
      - name: Download binary info artifact
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v6
        with:
          name: binary-info
          path: .

      - name: Set matrix environment variables
        shell: bash
        run: |
          set -x
          echo "IMAGE_NAME=u3s${{ matrix.image_suffix }}" >> $GITHUB_ENV
          echo "TAG_VERSION=${{ inputs.coreos_version }}${{ matrix.nvidia_tag }}" >> $GITHUB_ENV
          cat stream-info.env >> $GITHUB_ENV
          cat kubernetes-info.env >> $GITHUB_ENV
          cat binary-info.env >> $GITHUB_ENV

      - name: Pull base and kmod images
        uses: Wandalen/wretry.action@e68c23e6309f2871ca8ae4763e7629b9c258e1ea # v3.8.0
        with:
          attempt_limit: 3
          attempt_delay: 15000
          command: |
            # pull the base image used for FROM in containerfile so
            # we can retry on that unfortunately common failure case
            podman pull quay.io/fedora/fedora-coreos:${{ env.IMAGE_VERSION }}
            podman pull ghcr.io/ublue-os/akmods-nvidia:${{ env.KERNEL_FLAVOR }}-${{ env.FEDORA_VERSION }}
            podman pull ghcr.io/ublue-os/akmods-zfs:${{ env.KERNEL_FLAVOR }}-${{ env.FEDORA_VERSION }}

      - name: Verify versions (image, kernel, ucore, k3s, k8, crio)
        shell: bash
        run: |
          set -x
          if [ -z "${{ env.FEDORA_VERSION }}" ] || [ "null" = "${{ env.FEDORA_VERSION }}" ]; then
              echo "env.FEDORA_VERSION must not be empty or null" >&2
              exit 1
          fi
          if [ -z "${{ env.IMAGE_VERSION }}" ] || [ "null" = "${{ env.IMAGE_VERSION }}" ]; then
              echo "env.IMAGE_VERSION must not be empty or null" >&2
              exit 1
          fi
          if [ -z "${{ env.KERNEL_VERSION }}" ] || [ "null" = "${{ env.KERNEL_VERSION }}" ]; then
              echo "env.KERNEL_VERSION must not be empty or null" >&2
              exit 1
          fi
          podman inspect ghcr.io/ublue-os/akmods-zfs:${{ env.KERNEL_FLAVOR }}-${{ env.FEDORA_VERSION }} > inspect.json
          kernel=$(jq -r '.[]["Config"]["Labels"]["ostree.linux"]' inspect.json)
          if [[ "${{ env.KERNEL_VERSION }}" != "$kernel"*  ]]; then
              echo "pulled akmods-zfs image kernel ($kernel) does not match expected kernel (${{ env.KERNEL_VERSION }})" >&2
              exit 1
          fi
          if [ -z "${{ env.COREOS_VERSION }}" ] || [ "null" = "${{ env.COREOS_VERSION }}" ]; then
              echo "env.COREOS_VERSION must not be empty or null" >&2
              exit 1
          fi
          if [ -z "${{ env.K3S_VERSION }}" ] || [ "null" = "${{ env.K3S_VERSION }}" ]; then
              echo "env.K3S_VERSION must not be empty or null" >&2
              exit 1
          fi
          if [ -z "${{ env.K3S_BINARY_URL }}" ] || [ "null" = "${{ env.K3S_BINARY_URL }}" ]; then
              echo "env.K3S_BINARY_URL must not be empty or null" >&2
              exit 1
          fi
          if [ -z "${{ env.K3S_BINARY_DIGEST }}" ] || [ "null" = "${{ env.K3S_BINARY_URL }}" ]; then
              echo "env.K3S_BINARY_DIGEST must not be empty or null" >&2
              exit 1
          fi
          if [ -z "${{ env.K8S_VERSION }}" ] || [ "null" = "${{ env.K8S_VERSION }}" ]; then
              echo "env.K8S_VERSION must not be empty or null" >&2
              exit 1
          fi
          if [ -z "${{ env.CRIO_VERSION }}" ] || [ "null" = "${{ env.CRIO_VERSION }}" ]; then
              echo "env.CRIO_VERSION must not be empty or null" >&2
              exit 1
          fi
          if [ -z "${{ env.CALICO_VERSION }}" ] || [ "null" = "${{ env.CALICO_VERSION }}" ]; then
              echo "env.CALICO_VERSION must not be empty or null" >&2
              exit 1
          fi
          if [ -z "${{ env.CALICO_BINARY_URL }}" ] || [ "null" = "${{ env.CALICO_BINARY_URL }}" ]; then
              echo "env.CALICO_BINARY_URL must not be empty or null" >&2
              exit 1
          fi
          if [ -z "${{ env.CALICO_BINARY_DIGEST }}" ] || [ "null" = "${{ env.CALICO_BINARY_DIGEST }}" ]; then
              echo "env.CALICO_BINARY_DIGEST must not be empty or null" >&2
              exit 1
          fi
          if [ -z "${{ env.HELM_VERSION }}" ] || [ "null" = "${{ env.HELM_VERSION }}" ]; then
              echo "env.HELM_VERSION must not be empty or null" >&2
              exit 1
          fi
          if [ -z "${{ env.HELM_BINARY_URL }}" ] || [ "null" = "${{ env.HELM_BINARY_URL }}" ]; then
              echo "env.HELM_BINARY_URL must not be empty or null" >&2
              exit 1
          fi

      - name: Verify versions (nvidia)
        if: matrix.nvidia_tag == '-nvidia'
        shell: bash
        run: |
          set -x
          podman inspect ghcr.io/ublue-os/akmods-nvidia:${{ env.KERNEL_FLAVOR }}-${{ env.FEDORA_VERSION }} > inspect.json
          kernel=$(jq -r '.[]["Config"]["Labels"]["ostree.linux"]' inspect.json)
          if [[ "${{ env.KERNEL_VERSION }}" != "$kernel"*  ]]; then
              echo "pulled akmods-nvidia image kernel ($kernel) does not match expected kernel (${{ env.KERNEL_VERSION }})"
              exit 1
          fi

      - name: Image Metadata
        uses: docker/metadata-action@318604b99e75e41977312d83839a89be02ca4893 # v5
        id: meta
        with:
          labels: |
            io.artifacthub.package.readme-url=https://raw.githubusercontent.com/${{ github.repository_owner }}/u3s/main/README.md
            org.opencontainers.image.created=${{ steps.date.outputs.date }}
            org.opencontainers.image.description=${{ matrix.description }}
            org.opencontainers.image.title=${{ env.IMAGE_NAME }}
            org.opencontainers.image.url=https://github.com/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}
            org.opencontainers.image.vendor=${{ github.repository_owner }}
            org.opencontainers.image.version=${{ env.IMAGE_VERSION}}-${{ env.K3S_VERSION }}
            io.artifacthub.package.deprecated=false
            io.artifacthub.package.keywords=${{ env.IMAGE_KEYWORDS }}
            io.artifacthub.package.license=Apache-2.0
            io.artifacthub.package.logo-url=${{ env.IMAGE_LOGO_URL }}
            io.artifacthub.package.prerelease=false
            containers.bootc=1
          tags: |
            # multi-arch build must have only the single tag here
            # other tags are added to manifest later
            type=sha,format=short,suffix=-${{ env.TAG_VERSION }}-${{ matrix.arch }}

      - name: Single Line (convert newlines to spaces)
        id: single-line
        run: |
          # redhat/push-to-registry does NOT like multi-line tags
          tags="${{ steps.meta.outputs.tags }}"
          tags_space=$(printf '%s' "$tags" | tr '\n' ' ' | xargs)
          echo "tags=${tags_space}" >> $GITHUB_OUTPUT

      - name: Build Image
        id: build_image
        uses: redhat-actions/buildah-build@7a95fa7ee0f02d552a32753e7414641a04307056 # v2
        with:
          containerfiles: |
            ./u3s/Containerfile
          context: ./u3s
          image: ${{ env.IMAGE_NAME }}
          tags: |
            ${{ steps.single-line.outputs.tags }}
          build-args: |
            COREOS_VERSION=${{ inputs.coreos_version }}
            FEDORA_VERSION=${{ env.FEDORA_VERSION }}
            IMAGE_VERSION=${{ env.IMAGE_VERSION }}
            IMAGE_REGISTRY=${{ env.IMAGE_REGISTRY }}
            KERNEL_FLAVOR=${{ env.KERNEL_FLAVOR }}
            PR_PREFIX=${{ env.PR_PREFIX }}
            NVIDIA_TAG=${{ matrix.nvidia_tag }}
            K3S_VERSION=${{ env.K3S_VERSION }}
            K3S_BINARY_URL=${{ env.K3S_BINARY_URL }}
            K3S_BINARY_DIGEST=${{ env.K3S_BINARY_DIGEST }}
            K8S_VERSION=${{ env.K8S_VERSION }}
            CRIO_VERSION=${{ env.CRIO_VERSION }}
            CALICO_VERSION=${{ env.CALICO_VERSION }}
            CALICO_BINARY_URL=${{ env.CALICO_BINARY_URL }}
            CALICO_BINARY_DIGEST=${{ env.CALICO_BINARY_DIGEST }}
            HELM_VERSION=${{ env.HELM_VERSION }}
            HELM_BINARY_URL=${{ env.HELM_BINARY_URL }}
            HELM_BINARY_TARBALL=${{ env.HELM_BINARY_TARBALL }}
          labels: ${{ steps.meta.outputs.labels }}
          oci: true
          extra-args: |
            --target=${{ env.IMAGE_NAME }}

      - name: Push Image to Registry
        uses: Wandalen/wretry.action@e68c23e6309f2871ca8ae4763e7629b9c258e1ea # v3.8.0
        id: push
        if: github.event_name != 'pull_request'
        env:
          REGISTRY_USER: ${{ github.actor }}
          REGISTRY_PASSWORD: ${{ github.token }}
        with:
          action: redhat-actions/push-to-registry@5ed88d269cf581ea9ef6dd6806d01562096bee9c # v2
          attempt_limit: 3
          attempt_delay: 15000
          with: |
            image: ${{ steps.build_image.outputs.image }}
            tags: ${{ steps.build_image.outputs.tags }}
            registry: ${{ env.IMAGE_REGISTRY }}
            username: ${{ env.REGISTRY_USER }}
            password: ${{ env.REGISTRY_PASSWORD }}
            extra-args: |
              --disable-content-trust

      - name: Save image metadata
        if: github.event_name != 'pull_request'
        run: |
          set -x
          echo "IMAGE_ARCH=${{ matrix.arch }}" >> image.env
          echo "IMAGE_DIGEST=${{ fromJSON(steps.push.outputs.outputs).digest }}" >> image.env
          echo "IMAGE_REF=${{ fromJSON(steps.push.outputs.outputs).registry-path }}" >> image.env
          echo "${{ steps.meta.outputs.labels }}" > labels.txt

      - name: Upload image metadata as artifact
        if: github.event_name != 'pull_request'
        uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4 # v5.0.0
        with:
          name: image-u3s${{ matrix.image_suffix }}${{ matrix.nvidia_tag != '' && matrix.nvidia_tag || '-default' }}-${{ matrix.arch }}
          path: |
            image.env
            labels.txt
          retention-days: 7

  check_builds:
    name: Check builds successful
    runs-on: ubuntu-latest
    needs: [build_image]
    permissions: {}
    steps:
      - name: Exit
        env:
          RESULT: ${{ needs.build_image.result }}
        run: |
          if [[ "$RESULT" == "success" || "$RESULT" == "skipped" ]]; then
            exit 0
          else
            exit 1
          fi

  push_and_sign:
    name: "Push and sign: ucore${{ matrix.image_suffix }}${{ matrix.nvidia_tag }}"
    runs-on: ubuntu-24.04
    if: needs.check_builds.result == 'success' && !cancelled() && github.event_name != 'pull_request'
    needs: [workflow_info, check_builds, build_image]
    permissions:
      actions: read
      contents: read
      packages: write
    strategy:
      fail-fast: false
      matrix:
        image_suffix:
          - ""
        nvidia_tag:
          - "-nvidia"
          - ""
    steps:
      - name: Mount BTRFS for podman storage
        uses: ublue-os/container-storage-action@main

      - name: Set matrix environment variables
        shell: bash
        run: |
          set -x
          echo "IMAGE_NAME=ucore${{ matrix.image_suffix }}" >> $GITHUB_ENV
          echo "TAG_VERSION=${{ inputs.coreos_version }}${{ matrix.nvidia_tag }}" >> $GITHUB_ENV

      - name: Download image artifacts
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v6
        with:
          pattern: image-ucore${{ matrix.image_suffix }}${{ matrix.nvidia_tag != '' && matrix.nvidia_tag || '-default' }}-*
          path: images

      - name: Manifest Meta Tags
        uses: docker/metadata-action@c299e40c65443455700f0fdfc63efafe5b349051 # v5
        id: meta
        with:
          tags: |
            type=sha,format=short,suffix=-${{ env.TAG_VERSION }}
            type=ref,event=pr,suffix=-${{ env.TAG_VERSION }}
            type=raw,value=${{ env.TAG_VERSION }}-${{ needs.workflow_info.outputs.date }},priority=750,enable=${{ (github.event_name == 'push' || github.event_name == 'workflow_dispatch' || github.event_name == 'schedule') && startsWith(github.ref, 'refs/heads/main') }}
            type=raw,value=${{ env.TAG_VERSION }},priority=350,enable=${{ (github.event_name == 'push' || github.event_name == 'workflow_dispatch' || github.event_name == 'schedule') && startsWith(github.ref, 'refs/heads/main') }}
            type=raw,value=${{ env.TAG_VERSION }}-zfs-${{ needs.workflow_info.outputs.date }},priority=700,enable=${{ (github.event_name == 'push' || github.event_name == 'workflow_dispatch' || github.event_name == 'schedule') && startsWith(github.ref, 'refs/heads/main') }}
            type=raw,value=${{ env.TAG_VERSION }}-zfs,priority=300,enable=${{ (github.event_name == 'push' || github.event_name == 'workflow_dispatch' || github.event_name == 'schedule') && startsWith(github.ref, 'refs/heads/main') }}
            type=raw,value=latest,enable=${{ (github.event_name == 'push' || github.event_name == 'workflow_dispatch' || github.event_name == 'schedule') && startsWith(github.ref, 'refs/heads/main') && env.TAG_VERSION == 'stable' }}

      - name: Single Line (convert newlines to spaces)
        id: single-line
        run: |
          # redhat/push-to-registry does NOT like multi-line tags
          tags="${{ steps.meta.outputs.tags }}"
          tags_space=$(printf '%s' "$tags" | tr '\n' ' ' | xargs)
          echo "tags=${tags_space}" >> $GITHUB_OUTPUT

      - name: Update Buildah
        run: |
          set -euo pipefail

          case "$(uname -m)" in
            x86_64) IMAGE_ARCH='amd64' ;;
            aarch64) IMAGE_ARCH='arm64' ;;
            *) printf "Invalid architecture" >&2; exit 1 ;;
          esac

          echo "Installing up to date buildah for $IMAGE_ARCH"
          curl -fsSL https://github.com/bsherman/buildah-static/releases/latest/download/buildah-${IMAGE_ARCH:?}.tar.gz \
            | tar -xzf - -C /usr/local/bin/

          # Workaround issues between custom buildah installation and apparmor
          sudo sysctl -w kernel.apparmor_restrict_unprivileged_userns=0

      - name: Create multi-arch manifest
        shell: bash
        run: |
          set -xeuo pipefail

          # Collect image references from all arches in artifacts
          IMAGE_REFS=()
          for IMAGE_ENV in $(find images -type f -path "images/image-ucore${{ matrix.image_suffix }}*/image.env"); do
            source "$IMAGE_ENV" # provides IMAGE_REF and IMAGE_ARCH
            IMAGE_REFS+=("$IMAGE_REF")
            echo "Importing ${IMAGE_REF:?} for architecture ${IMAGE_ARCH:?}"
            buildah pull --arch="${IMAGE_ARCH:?}" "${IMAGE_REF:?}"
          done

          echo
          echo "Creating manifest for $IMAGE_NAME"
          # Pick labels.txt from any of the arches in artifacts (identical for all images in each variant)
          LABELS_FILE=$(find images -type f -path "images/image-ucore${{ matrix.image_suffix }}*/labels.txt" | head -n1)
          buildah manifest create --annotation="$(
            cat $LABELS_FILE | \
              head -c -1 | sed -e 's/, \{0,1\}/ /g' | tr '\n' ','
          )" "${IMAGE_NAME:?}"

          for IMAGE_REF in "${IMAGE_REFS[@]}"; do
            echo "Adding ${IMAGE_REF:?} to manifest"
            buildah manifest add "${IMAGE_NAME:?}" "$IMAGE_REF"
          done

          MANIFEST_TAGS='${{ steps.meta.outputs.tags }}'
          while IFS= read -r TAG; do
            buildah tag "${IMAGE_NAME:?}" "${IMAGE_NAME:?}:${TAG:?}"
          done <<< "$MANIFEST_TAGS"

          echo
          echo 'Final manifest contents:'
          buildah manifest inspect "${IMAGE_NAME:?}"
          echo
          echo 'Podman image state:'
          podman images

      - name: Push Manifest to GHCR
        uses: Wandalen/wretry.action@e68c23e6309f2871ca8ae4763e7629b9c258e1ea # v3.8.0
        id: push
        with:
          action: redhat-actions/push-to-registry@5ed88d269cf581ea9ef6dd6806d01562096bee9c # v2
          attempt_limit: 3
          attempt_delay: 15000
          with: |
            image: ${{ env.IMAGE_NAME }}
            tags:  ${{ steps.single-line.outputs.tags }}
            registry: ${{ env.IMAGE_REGISTRY }}
            username: ${{ github.actor }}
            password: ${{ github.token }}

      - name: Login to GitHub Container Registry
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3
        if: github.event_name != 'pull_request'
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Sign container
      - uses: sigstore/cosign-installer@faadad0cce49287aee09b3a48701e75088a2c6ad # v4.0.0
        if: github.event_name != 'pull_request'
        with:
          cosign-release: "v2.6.1"

      - name: Sign member images
        if: github.event_name != 'pull_request'
        shell: bash
        env:
          COSIGN_EXPERIMENTAL: false
          COSIGN_PRIVATE_KEY: ${{ secrets.SIGNING_SECRET }}
        run: |
          # Sign each member image (IMAGE_REF@IMAGE_DIGEST) from the build artifacts.
          set -xeuo pipefail

          shopt -s nullglob
          ENVFILES=(images/*/image.env)
          if [ ${#ENVFILES[@]} -eq 0 ]; then
            echo "No image.env files found under images/; nothing to sign"
            exit 0
          fi

          for f in "${ENVFILES[@]}"; do
            echo "Sourcing $f"
            # shellcheck disable=SC1090
            source "$f"   # sets IMAGE_REF and IMAGE_DIGEST
            if [ -z "${IMAGE_REF:-}" ] || [ -z "${IMAGE_DIGEST:-}" ]; then
              echo "Missing IMAGE_REF or IMAGE_DIGEST in $f" >&2
              exit 1
            fi
            echo "Signing ${IMAGE_REF}@${IMAGE_DIGEST}"
            cosign sign -y --key env://COSIGN_PRIVATE_KEY "${IMAGE_REF}@${IMAGE_DIGEST}"
          done

      - name: Sign container manifest
        if: github.event_name != 'pull_request'
        env:
          REGISTRY_PATH: ${{ steps.push.outputs.outputs && fromJSON(steps.push.outputs.outputs).registry-path }}
          DIGEST: ${{ steps.push.outputs.outputs && fromJSON(steps.push.outputs.outputs).digest }}
          COSIGN_EXPERIMENTAL: false
          COSIGN_PRIVATE_KEY: ${{ secrets.SIGNING_SECRET }}
        run: |
          echo "Signing ${{ env.REGISTRY_PATH }}@${{ env.DIGEST }}"
          cosign sign -y --key env://COSIGN_PRIVATE_KEY ${{ env.REGISTRY_PATH }}@${{ env.DIGEST }}

  check:
    name: Check all successful
    runs-on: ubuntu-latest
    needs: [push_and_sign]
    permissions: {}
    steps:
      - name: Exit
        env:
          RESULT: ${{ needs.push_and_sign.result }}
        run: |
          if [[ "$RESULT" == "success" || "$RESULT" == "skipped" ]]; then
            exit 0
          else
            exit 1
          fi
